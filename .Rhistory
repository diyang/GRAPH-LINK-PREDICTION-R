iso <- which(V(sub.graph)$name < 0)
sub.graph <- delete.vertices(sub.graph, iso)
a <- sub.graph$a
b <- sub.graph$b
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "tomato", "gold")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
a
b
a <- 2703
b <- 1369
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "tomato", "gold")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
sorted.vertices <- all.vertices[order(label.vertices)]
if(!is.null(max.nodes)){
if(num.vertices > max.nodes){
sorted.node.a.index <- which(sorted.vertices == nodes.pairs[[i]]$a)
sorted.node.b.index <- which(sorted.vertices == nodes.pairs[[i]]$b)
if(sorted.node.a.index > max.nodes && sorted.node.b.index <= max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes):num.vertices)]
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$a)
}else if(sorted.node.a.index <= max.nodes && sorted.node.b.index > max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes):num.vertices)]
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$b)
}else if(sorted.node.a.index  > max.nodes && sorted.node.b.index > max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes-1):num.vertices)]
if(sorted.node.a.index < sorted.node.b.index){
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$a, nodes.pairs[[i]]$b)
}else{
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$b, nodes.pairs[[i]]$a)
}
}else{
sorted.vertices <- sorted.vertices[-((max.nodes+1):num.vertices)]
}
}
}
subgraph.adj <- subgraph.adj.extract(sorted.vertices, max.nodes, adj)
sub.graph <- graph_from_adjacency_matrix(subgraph.adj, mode = "undirected" )
V(sub.graph)$name <- sorted.vertices
a
b
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "tomato", "gold")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
require(mxnet)
#windows
#setwd("I:/Desktop/R/SAGE-GRAPH-R/graph_link_prediction")
#Mac
setwd("~/Documents/GRAPH-LINK-PREDICTION-R")
source("model.R")
source("utils.R")
source("train.R")
gcn.pair.train.input <- Graph.enclose.encode(node.pair.train.batch, graph.input$adjmatrix, K, max.nodes)
require(mxnet)
#windows
#setwd("I:/Desktop/R/SAGE-GRAPH-R/graph_link_prediction")
#Mac
setwd("~/Documents/GRAPH-LINK-PREDICTION-R")
source("model.R")
source("utils.R")
source("train.R")
# load graph
org.graph.input <- loaddata.cora()
data <-as.matrix(org.graph.input$content[, -which(names(org.graph.input$content) %in% c("paper_id", "class"))])
org.graph.input[["features"]] <- data
adj <- org.graph.input$adjmatrix
edge.list <- as_edgelist(org.graph.input$graph)
# deliberately extract some edges, and re-construct graph
set.seed(123)
batch.size <- 100
num.edge <- dim(edge.list)[1]
pos.pair.indices.pool <- sample(c(1:num.edge), (batch.size*3), replace=FALSE)
positive.nodes.pairs <- list()
count <- 1
for(i in pos.pair.indices.pool){
node.pair <- list(a=edge.list[i,1], b=edge.list[i,2])
positive.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
num.node <- dim(adj)[1]
neg.pair.indices.pool <- sample(c(1:num.node), (batch.size*3), replace=FALSE)
negative.nodes.pairs <- list()
count <- 1
negative.edge.list <- c()
for(i in neg.pair.indices.pool){
null.edge <- which(adj[i,] == 0)
num.null.edge <- length(null.edge)
if(num.null.edge > 0){
neg.index <- sample(c(1:num.null.edge), 1)
node.pair <- list(a=i, b=null.edge[neg.index])
negative.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
}
positive.label <- rep(1, length(positive.nodes.pairs))
negative.label <- rep(2, length(negative.nodes.pairs))
nodes.pairs <- c(positive.nodes.pairs, negative.nodes.pairs)
pairs.label <- c(positive.label, negative.label)
num.pairs <- length(nodes.pairs)
shuffled.indices <- sample(c(1:num.pairs))
shuffled.nodes.pairs <- nodes.pairs[shuffled.indices]
shuffled.pairs.label <- pairs.label[shuffled.indices]
new.edge.list <- edge.list[-(pos.pair.indices.pool),]
new.graph <- graph_from_edgelist(new.edge.list, directed = FALSE)
adjmatrix <- as_adj(new.graph, type = 'both', sparse = igraph_opt("sparsematrices"))
D.sqrt <- sqrt(colSums(adjmatrix))
A.tilde <- adjmatrix + Diagonal(dim(adjmatrix)[1])
P <- diag(D.sqrt)%*%A.tilde%*% diag(D.sqrt)
new.graph.input <- list(adjmatrix = adjmatrix, P = P, Atilde = A.tilde, Dsqrt = D.sqrt, graph = new.graph)
new.graph.input[['features']] <- data
K <- 2
batch.size <- 50
num.hidden <- c(20,20)
max.nodes <- 100
num.filters <- c(5,3)
input.size <- dim(data)[2]
gcn.sym <- GCN.layer.link.prediction(input.size,
max.nodes,
batch.size,
num.hidden,
num.filters)
gcn.model <- GCN.link.setup.model(gcn.sym,
max.nodes,
input.size,
batch.size,
K=2)
train.nodes.pairs <- shuffled.nodes.pairs[1:(4*batch.size)]
train.pairs.label <- shuffled.pairs.label[1:(4*batch.size)]
valid.nodes.pairs <- shuffled.nodes.pairs[(4*batch.size+1):num.pairs]
valid.pairs.label <- shuffled.pairs.label[(4*batch.size+1):num.pairs]
train.data <- list(nodes.pairs=train.nodes.pairs, pairs.label=train.pairs.label)
valid.data <- list(nodes.pairs=valid.nodes.pairs, pairs.label=valid.pairs.label)
learning.rate <- 0.01
weight.decay <- 0
clip.gradient <- 1
optimizer <- 'sgd'
lr.scheduler <- mx.lr_scheduler.FactorScheduler(step = 480, factor=0.5, stop_factor_lr = 1e-3)
model <- gcn.model
graph.input <- new.graph.input
m <- model
batch.size <- m$batch.size
input.size <- m$input.size
max.nodes <- m$max.nodes
K <- m$K
opt <- mx.opt.create(optimizer, learning.rate = learning.rate,
wd = weight.decay,
rescale.grad = 1, #(1/batch.size),
clip_gradient=clip.gradient,
lr_scheduler = lr.scheduler)
opt.updater <- mx.opt.get.updater(opt, m$gcn.exec$ref.arg.arrays)
train.nll <- 0
num.batch.train <- floor(length(train.data$nodes.pairs)/batch.size)
batch.counter <- 1
batch.begin <- (batch.counter-1)*batch.size+1
node.pair.train.batch       <- train.data$nodes.pairs[batch.begin:(batch.begin+batch.size-1)]
node.pair.train.label.batch <- train.data$pairs.label[batch.begin:(batch.begin+batch.size-1)]
gcn.pair.train.input <- Graph.enclose.encode(node.pair.train.batch, graph.input$adjmatrix, K, max.nodes)
Graph.enclose.encode <- function(nodes.pairs,
adj,
K,
max.nodes=NULL)
{
num.pairs <- length(nodes.pairs)
outputs <- list()
for(i in 1:num.pairs){
# K-hop neigborhood search
for(hop in 1:K){
if(hop == 1){
temp.nodes.pool <- c(nodes.pairs[[i]]$a, nodes.pairs[[i]]$b)
#temp.nodes.pool <- c(2703,1369)
all.vertices <- temp.nodes.pool
}else{
temp.nodes.pool <- temp.neigbor
}
temp.initial <- TRUE
for(node in temp.nodes.pool){
if(temp.initial){
temp.neigbor <- which(adj[node,]>0)
temp.initial <- FALSE
}else{
temp.neigbor <- c(temp.neigbor, which(adj[node,]>0))
}
}
temp.neigbor <- unique(temp.neigbor)
all.vertices <- c(all.vertices, temp.neigbor)
}
all.vertices <- unique(all.vertices)
# Weisfeiler-Lehman Graph labeling
num.vertices <- length(all.vertices)
label.vertices <- rep(1, num.vertices)
decimal.vertices <- rep(1, num.vertices)
label.vertices.changed <- TRUE
while(label.vertices.changed){
for(node.index in 1:num.vertices){
node <- all.vertices[node.index]
neigbor.nodes <- which(adj[node,]>0)
neigbor.indicies <- which(all.vertices %in% neigbor.nodes)
if(length(neigbor.indicies) > 0){
neigbor.decimals <- array2decimal(sort(label.vertices[neigbor.indicies]))
}else{
neigbor.decimals <- 0
}
#update labeling
decimal.vertices[node.index] <- label.vertices[node.index]+neigbor.decimals
}
sorted.decimal.vertices <- sort(decimal.vertices, index.return=TRUE)
label <- 1
label.vertices.old <- label.vertices
for(sort.index in 1:num.vertices){
if(sort.index == 1){
label.vertices[sorted.decimal.vertices$ix[sort.index]] <- label
tmp.decimal.vertex <- sorted.decimal.vertices$x[sort.index]
}else{
if(tmp.decimal.vertex < sorted.decimal.vertices$x[sort.index]){
label <- label+1
}
label.vertices[sorted.decimal.vertices$ix[sort.index]] <- label
tmp.decimal.vertex <- sorted.decimal.vertices$x[sort.index]
}
}
label.vertices.changed <- !(sum(((label.vertices.old-label.vertices)**2)) == 0)
}
sorted.vertices <- all.vertices[order(-label.vertices)]
if(!is.null(max.nodes)){
if(num.vertices > max.nodes){
sorted.node.a.index <- which(sorted.vertices == nodes.pairs[[i]]$a)
sorted.node.b.index <- which(sorted.vertices == nodes.pairs[[i]]$b)
if(sorted.node.a.index > max.nodes && sorted.node.b.index <= max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes):num.vertices)]
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$a)
}else if(sorted.node.a.index <= max.nodes && sorted.node.b.index > max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes):num.vertices)]
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$b)
}else if(sorted.node.a.index  > max.nodes && sorted.node.b.index > max.nodes){
sorted.vertices <- sorted.vertices[-((max.nodes-1):num.vertices)]
if(sorted.node.a.index < sorted.node.b.index){
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$a, nodes.pairs[[i]]$b)
}else{
sorted.vertices <- c(sorted.vertices, nodes.pairs[[i]]$b, nodes.pairs[[i]]$a)
}
}else{
sorted.vertices <- sorted.vertices[-((max.nodes+1):num.vertices)]
}
}
}
subgraph.adj <- subgraph.adj.extract(sorted.vertices, max.nodes, adj)
subgraph.tP <- chebyshev.polynomials(subgraph.adj, K)
nodes.pairs.data <- list(a=nodes.pairs[[i]]$a, b=nodes.pairs[[i]]$b, sorted_neighbors=sorted.vertices, tP=subgraph.tP, adj=subgraph.adj)
outputs[[i]] <- nodes.pairs.data
}
return(outputs)
}
batch.begin <- (batch.counter-1)*batch.size+1
node.pair.train.batch       <- train.data$nodes.pairs[batch.begin:(batch.begin+batch.size-1)]
node.pair.train.label.batch <- train.data$pairs.label[batch.begin:(batch.begin+batch.size-1)]
gcn.pair.train.input <- Graph.enclose.encode(node.pair.train.batch, graph.input$adjmatrix, K, max.nodes)
gcn.pair.train.input[[1]]$a
gcn.pair.train.input[[1]]$b
sub.graph.display(gcn.pair.train.input[[1]])
gcn.pair.train.input[[1]]$sorted_neighbors
sub.graph <- gcn.pair.train.input[[1]]
max.nodes <- dim(sub.graph$adj)[1]
sub.graph <- graph_from_adjacency_matrix(sub.graph$adj, mode = "undirected" )
plot.igraph(sub.graph)
num.vertices <- length(sub.graph$sorted_neighbors)
if(num.vertices < max.nodes){
padding.vertices <- c(-1:-(max.nodes-num.vertices))
vertices.names <- c(sub.graph$sorted_neighbors, padding.vertices)
}else{
vertices.names <- sub.graph$sorted_neighbors
}
vertices.names
num.vertices
sub.graph$sorted_neighbors
gcn.pair.train.input[[1]]$sorted_neighbors
sub.graph.input <- gcn.pair.train.input[[1]]
sub.graph.display(sub.graph.input)
max.nodes <- dim(sub.graph.input$adj)[1]
max.nodes
sub.graph <- graph_from_adjacency_matrix(sub.graph.input$adj, mode = "undirected" )
plot(sub.graph)
num.vertices <- length(sub.graph.input$sorted_neighbors)
num.vertices
if(num.vertices < max.nodes){
padding.vertices <- c(-1:-(max.nodes-num.vertices))
vertices.names <- c(sub.graph.input$sorted_neighbors, padding.vertices)
}else{
vertices.names <- sub.graph.input$sorted_neighbors
}
vertices.names
V(sub.graph)$name <- vertices.names
iso <- which(V(sub.graph)$name < 0)
sub.graph <- delete.vertices(sub.graph, iso)
a <- sub.graph.input$a
b <- sub.graph.input$b
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "tomato", "gold")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "gold", "tomato")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
sub.graph.display(sub.graph.input)
sub.graph.display <- function(sub.graph.input)
{
max.nodes <- dim(sub.graph.input$adj)[1]
sub.graph <- graph_from_adjacency_matrix(sub.graph.input$adj, mode = "undirected" )
num.vertices <- length(sub.graph.input$sorted_neighbors)
if(num.vertices < max.nodes){
padding.vertices <- c(-1:-(max.nodes-num.vertices))
vertices.names <- c(sub.graph.input$sorted_neighbors, padding.vertices)
}else{
vertices.names <- sub.graph.input$sorted_neighbors
}
V(sub.graph)$name <- vertices.names
iso <- which(V(sub.graph)$name < 0)
sub.graph <- delete.vertices(sub.graph, iso)
a <- sub.graph.input$a
b <- sub.graph.input$b
plot(sub.graph, vertex.label.color="black",
vertex.color=c( "tomato", "gold")[1+(V(sub.graph)$name %in% c(a,b))],
edge.width=3, vertex.size = c(15,18)[1+(V(sub.graph)$name %in% c(a,b))])
}
sub.graph.display(sub.graph.input)
require(mxnet)
#windows
#setwd("I:/Desktop/R/SAGE-GRAPH-R/graph_link_prediction")
#Mac
setwd("~/Documents/GRAPH-LINK-PREDICTION-R")
source("model.R")
source("utils.R")
source("train.R")
# load graph
org.graph.input <- loaddata.cora()
data <-as.matrix(org.graph.input$content[, -which(names(org.graph.input$content) %in% c("paper_id", "class"))])
org.graph.input[["features"]] <- data
adj <- org.graph.input$adjmatrix
edge.list <- as_edgelist(org.graph.input$graph)
# deliberately extract some edges, and re-construct graph
set.seed(123)
batch.size <- 100
num.edge <- dim(edge.list)[1]
pos.pair.indices.pool <- sample(c(1:num.edge), (batch.size*3), replace=FALSE)
positive.nodes.pairs <- list()
count <- 1
for(i in pos.pair.indices.pool){
node.pair <- list(a=edge.list[i,1], b=edge.list[i,2])
positive.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
num.node <- dim(adj)[1]
neg.pair.indices.pool <- sample(c(1:num.node), (batch.size*3), replace=FALSE)
negative.nodes.pairs <- list()
count <- 1
negative.edge.list <- c()
for(i in neg.pair.indices.pool){
null.edge <- which(adj[i,] == 0)
num.null.edge <- length(null.edge)
if(num.null.edge > 0){
neg.index <- sample(c(1:num.null.edge), 1)
node.pair <- list(a=i, b=null.edge[neg.index])
negative.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
}
positive.label <- rep(1, length(positive.nodes.pairs))
negative.label <- rep(2, length(negative.nodes.pairs))
nodes.pairs <- c(positive.nodes.pairs, negative.nodes.pairs)
pairs.label <- c(positive.label, negative.label)
num.pairs <- length(nodes.pairs)
shuffled.indices <- sample(c(1:num.pairs))
shuffled.nodes.pairs <- nodes.pairs[shuffled.indices]
shuffled.pairs.label <- pairs.label[shuffled.indices]
new.edge.list <- edge.list[-(pos.pair.indices.pool),]
new.graph <- graph_from_edgelist(new.edge.list, directed = FALSE)
adjmatrix <- as_adj(new.graph, type = 'both', sparse = igraph_opt("sparsematrices"))
D.sqrt <- sqrt(colSums(adjmatrix))
A.tilde <- adjmatrix + Diagonal(dim(adjmatrix)[1])
P <- diag(D.sqrt)%*%A.tilde%*% diag(D.sqrt)
new.graph.input <- list(adjmatrix = adjmatrix, P = P, Atilde = A.tilde, Dsqrt = D.sqrt, graph = new.graph)
new.graph.input[['features']] <- data
K <- 2
batch.size <- 50
num.hidden <- c(20,20)
max.nodes <- 100
num.filters <- c(5,3)
input.size <- dim(data)[2]
gcn.sym <- GCN.layer.link.prediction(input.size,
max.nodes,
batch.size,
num.hidden,
num.filters)
gcn.model <- GCN.link.setup.model(gcn.sym,
max.nodes,
input.size,
batch.size,
K=2)
train.nodes.pairs <- shuffled.nodes.pairs[1:(4*batch.size)]
train.pairs.label <- shuffled.pairs.label[1:(4*batch.size)]
valid.nodes.pairs <- shuffled.nodes.pairs[(4*batch.size+1):num.pairs]
valid.pairs.label <- shuffled.pairs.label[(4*batch.size+1):num.pairs]
train.data <- list(nodes.pairs=train.nodes.pairs, pairs.label=train.pairs.label)
valid.data <- list(nodes.pairs=valid.nodes.pairs, pairs.label=valid.pairs.label)
learning.rate <- 0.01
weight.decay <- 0
clip.gradient <- 1
optimizer <- 'sgd'
lr.scheduler <- mx.lr_scheduler.FactorScheduler(step = 480, factor=0.5, stop_factor_lr = 1e-3)
gcn.model.trained <- GCN.link.trian.model(model = gcn.model,
graph.input = new.graph.input,
train.data = train.data,
valid.data = valid.data,
num.epoch = 100,
learning.rate = learning.rate,
weight.decay = weight.decay,
clip.gradient = clip.gradient,
optimizer = optimizer)
dim(train.nodes.pairs)
length(train.nodes.pairs)
length(valid.nodes.pairs)
require(mxnet)
#windows
#setwd("I:/Desktop/R/SAGE-GRAPH-R/graph_link_prediction")
#Mac
setwd("~/Documents/GRAPH-LINK-PREDICTION-R")
source("model.R")
source("utils.R")
source("train.R")
# load graph
org.graph.input <- loaddata.cora()
data <-as.matrix(org.graph.input$content[, -which(names(org.graph.input$content) %in% c("paper_id", "class"))])
org.graph.input[["features"]] <- data
adj <- org.graph.input$adjmatrix
edge.list <- as_edgelist(org.graph.input$graph)
# deliberately extract some edges, and re-construct graph
set.seed(123)
batch.size <- 50
num.edge <- dim(edge.list)[1]
pos.pair.indices.pool <- sample(c(1:num.edge), (batch.size*3), replace=FALSE)
positive.nodes.pairs <- list()
count <- 1
for(i in pos.pair.indices.pool){
node.pair <- list(a=edge.list[i,1], b=edge.list[i,2])
positive.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
num.node <- dim(adj)[1]
neg.pair.indices.pool <- sample(c(1:num.node), (batch.size*3), replace=FALSE)
negative.nodes.pairs <- list()
count <- 1
negative.edge.list <- c()
for(i in neg.pair.indices.pool){
null.edge <- which(adj[i,] == 0)
num.null.edge <- length(null.edge)
if(num.null.edge > 0){
neg.index <- sample(c(1:num.null.edge), 1)
node.pair <- list(a=i, b=null.edge[neg.index])
negative.nodes.pairs[[count]] <- node.pair
count <- count + 1
}
}
positive.label <- rep(1, length(positive.nodes.pairs))
negative.label <- rep(2, length(negative.nodes.pairs))
nodes.pairs <- c(positive.nodes.pairs, negative.nodes.pairs)
pairs.label <- c(positive.label, negative.label)
num.pairs <- length(nodes.pairs)
shuffled.indices <- sample(c(1:num.pairs))
shuffled.nodes.pairs <- nodes.pairs[shuffled.indices]
shuffled.pairs.label <- pairs.label[shuffled.indices]
new.edge.list <- edge.list[-(pos.pair.indices.pool),]
new.graph <- graph_from_edgelist(new.edge.list, directed = FALSE)
adjmatrix <- as_adj(new.graph, type = 'both', sparse = igraph_opt("sparsematrices"))
D.sqrt <- sqrt(colSums(adjmatrix))
A.tilde <- adjmatrix + Diagonal(dim(adjmatrix)[1])
P <- diag(D.sqrt)%*%A.tilde%*% diag(D.sqrt)
new.graph.input <- list(adjmatrix = adjmatrix, P = P, Atilde = A.tilde, Dsqrt = D.sqrt, graph = new.graph)
new.graph.input[['features']] <- data
K <- 2
num.hidden <- c(20,20)
max.nodes <- 100
num.filters <- c(5,3)
input.size <- dim(data)[2]
gcn.sym <- GCN.layer.link.prediction(input.size,
max.nodes,
batch.size,
num.hidden,
num.filters)
gcn.model <- GCN.link.setup.model(gcn.sym,
max.nodes,
input.size,
batch.size,
K=2)
train.nodes.pairs <- shuffled.nodes.pairs[1:(4*batch.size)]
train.pairs.label <- shuffled.pairs.label[1:(4*batch.size)]
valid.nodes.pairs <- shuffled.nodes.pairs[(4*batch.size+1):num.pairs]
valid.pairs.label <- shuffled.pairs.label[(4*batch.size+1):num.pairs]
train.data <- list(nodes.pairs=train.nodes.pairs, pairs.label=train.pairs.label)
valid.data <- list(nodes.pairs=valid.nodes.pairs, pairs.label=valid.pairs.label)
learning.rate <- 0.01
weight.decay <- 0
clip.gradient <- 1
optimizer <- 'sgd'
lr.scheduler <- mx.lr_scheduler.FactorScheduler(step = 480, factor=0.5, stop_factor_lr = 1e-3)
gcn.model.trained <- GCN.link.trian.model(model = gcn.model,
graph.input = new.graph.input,
train.data = train.data,
valid.data = valid.data,
num.epoch = 100,
learning.rate = learning.rate,
weight.decay = weight.decay,
clip.gradient = clip.gradient,
optimizer = optimizer)
